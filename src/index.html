<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<input type="button" onclick="enableEraserHandler()" value="擦除"/>
<input type="button" onclick="enableDefaultHandler()" value="画笔"/>
<!--<input type="button" onclick="zoomUp()" value="放大"/>-->
<!--<input type="button" onclick="zoomReset()" value="恢复缩放"/>-->
<!--<input type="button" onclick="zoomIn()" value="缩小"/>-->
<input type="button" onclick="undo()" value="撤销"/>
<input type="button" onclick="redo()" value="重做"/>
<input type="button" onclick="save()" value="保存"/>
<input id="saveInput" value=""/>
<input type="button" onclick="load()" value="加载"/>
<input id="loadInput" value=""/>

<div id='pa' style="height: 320px;width:640px"></div>
<div id="log"></div>
<script>
    class PixelPad {
        canvasEl
        ctx
        option = {}
        optionOrigin = {}
        optionDefault = {
            bgColor: '#e8e8e8',
            drawColor: '#00a711',
            boxSize: 10,
            boxSizeMin: 5,
            boxSizeMax: 20,
            gridLineWidth: 1,
        }
        // isMoving = false
        isReducingDrewBox = false
        drawHistoryInfo = []
        drawHistoryInfoForRedo = []

        constructor(htmlNode, option) {
            this.option = {...this.optionDefault, ...option}
            this.optionOrigin = JSON.parse(JSON.stringify(this.option))
            this.initCanvasEl(htmlNode)
            this.setPad()
            this.setAction()
        }

        initCanvasEl(htmlNode) {
            const canvasEl = document.createElement('canvas');
            canvasEl.style.padding = '0'
            canvasEl.style.margin = '0'
            canvasEl.style.boxSizing = 'border-box'
            canvasEl.style.height = 100 + '%'
            canvasEl.style.width = 100 + '%'
            htmlNode.append(canvasEl)
            this.canvasEl = canvasEl
            this.ctx = canvasEl.getContext('2d')
        }

        setPad() {
            this.canvasEl.width = this.canvasEl.clientWidth
            this.canvasEl.height = this.canvasEl.clientHeight
            this.option.bgBoxNumX = parseInt(String(this.canvasEl.width / this.option.boxSize))
            this.option.bgBoxNumY = parseInt(String(this.canvasEl.height / this.option.boxSize))
            this.fillBg()
            this.fillBoxInCanvasFastByDrawHistoryInfo()
        }

        setAction() {
            const drawHandler = (e) => {
                const x = e.pageX - this.canvasEl.getBoundingClientRect().left
                const y = e.pageY - this.canvasEl.getBoundingClientRect().top
                const position = this.getBoxXY(x, y)
                this.drawBox(position.boxX, position.boxY)
            }
            // const moveHandler = (e) => {
            //
            // }

            // document.addEventListener('keydown', (e) => {
            //     if (e.key === 'Control') {
            //         this.canvasEl.style.cursor='move'
            //         this.isMoving = true
            //     }
            // })
            // document.addEventListener('keyup', (e) => {
            //     if (e.key === 'Control') {
            //         this.canvasEl.style.cursor='auto'
            //         this.isMoving = false
            //     }
            // })

            this.canvasEl.addEventListener("mousedown", (e) => {
                // if (this.isMoving) {
                //     this.canvasEl.addEventListener("mousemove", moveHandler)
                // } else {
                this.drawHistoryInfoForRedo = []
                this.drawHistoryInfo.push([])
                drawHandler(e)
                this.canvasEl.addEventListener("mousemove", drawHandler)
                // }
            })
            document.addEventListener("mouseup", () => {
                // this.canvasEl.removeEventListener("mousemove", moveHandler)
                this.canvasEl.removeEventListener("mousemove", drawHandler)
            })
        }

        fillBg() {
            for (let boxX = 0; boxX < this.option.bgBoxNumX; boxX++) {
                for (let boxY = 0; boxY < this.option.bgBoxNumY; boxY++) {
                    this.fillBoxInCanvas(boxX, boxY)
                }
            }
        }

        fillBoxInCanvas(boxX, boxY, color) {
            if (boxX >= 0 && boxX <= this.option.bgBoxNumX && boxY >= 0 && boxY <= this.option.bgBoxNumY) {
                const PixelX = boxX * this.option.boxSize
                const PixelY = boxY * this.option.boxSize
                this.ctx.beginPath()
                this.ctx.fillStyle = color || this.option.bgColor;
                this.ctx.fillRect(PixelX + this.option.gridLineWidth, PixelY + this.option.gridLineWidth, this.option.boxSize - this.option.gridLineWidth, this.option.boxSize - this.option.gridLineWidth);
                this.ctx.fill()
                this.ctx.stroke()
                this.ctx.closePath()
            }
        }

        // 使用历史记录中的点填充画板
        fillBoxInCanvasFastByDrawHistoryInfo() {
            const finallyDrawInfo = this.save()
            for (const pixel of finallyDrawInfo) {
                this.fillBoxInCanvas(pixel.x, pixel.y, pixel.color)
            }
        }


        //通过鼠标坐标，获取方块的个数横纵坐标
        getBoxXY(x, y) {
            const boxX = Math.floor(x / this.option.boxSize)
            const boxY = Math.floor(y / this.option.boxSize)
            return {boxX, boxY}
        }

        drawBox(boxX, boxY) {
            const currentDrawHistoryInfo = this.drawHistoryInfo[this.drawHistoryInfo.length - 1]
            currentDrawHistoryInfo.push({x: boxX, y: boxY, color: this.isReducingDrewBox ? null : this.option.drawColor})//擦除的位置color为null
            this.fillBoxInCanvas(boxX, boxY, this.isReducingDrewBox ? this.option.bgColor : this.option.drawColor)
        }

        // 切换当前使用工具
        setUsingTool(toolName) {
            switch (toolName) {
                case "eraser":
                    this.isReducingDrewBox = true
                    break;
                default:
                    this.isReducingDrewBox = false
                    break;
            }
        }

        // // 设置缩放等级
        // zoomUpdate(boxSize) {
        //     this.option.boxSize = Math.max(boxSize, this.option.boxSizeMin, 1)
        //     this.option.boxSize = Math.min(boxSize, this.option.boxSizeMax, 50)
        //     this.setPad()
        // }
        //
        // // 重置缩放等级
        // zoomReset() {
        //     this.option.boxSize = this.optionOrigin.boxSize
        //     this.setPad()
        // }

        // 撤销
        undo() {
            const undoDraw = this.drawHistoryInfo.pop()
            if (undoDraw) {
                this.drawHistoryInfoForRedo.push(undoDraw)
                this.fillBg()
                this.fillBoxInCanvasFastByDrawHistoryInfo()
            }
        }

        // 重做
        redo() {
            const redoDraw = this.drawHistoryInfoForRedo.pop()
            if (redoDraw) {
                this.drawHistoryInfo.push(redoDraw)
                this.fillBg()
                this.fillBoxInCanvasFastByDrawHistoryInfo()
            }
        }

        // 使用保存的绘画像素信息填充画板
        load(drawInfo) {
            this.fillBg()
            for (const pixel of drawInfo) {
                this.fillBoxInCanvas(pixel.x, pixel.y, pixel.color)
            }
        }

        // 获取最终绘画像素信息
        save() {
            const finallyDrawInfo = []
            for (const historyDraw of this.drawHistoryInfo) {
                for (const historyPixel of historyDraw) {
                    const existPixelIndex = finallyDrawInfo.findIndex(item => item && historyPixel && item.x === historyPixel.x && item.y === historyPixel.y)
                    if (existPixelIndex >= 0) {
                        if (historyPixel.color === null) {
                            delete finallyDrawInfo[existPixelIndex]
                        } else {
                            finallyDrawInfo[finallyDrawInfo] = historyPixel
                        }
                    } else {
                        finallyDrawInfo.push(historyPixel)
                    }
                }
            }
            return finallyDrawInfo.filter(e => e)
        }
    }

    const pixelPad = new PixelPad(document.getElementById('pa'))

    function enableEraserHandler() {
        pixelPad.setUsingTool('eraser')
    }

    function enableDefaultHandler() {
        pixelPad.setUsingTool()
    }

    // function zoomUp() {
    //     pixelPad.zoomUpdate(pixelPad.option.boxSize + 2)
    // }
    //
    // function zoomIn() {
    //     pixelPad.zoomUpdate(pixelPad.option.boxSize - 2)
    // }
    //
    // function zoomReset() {
    //     pixelPad.zoomReset()
    // }

    function undo() {
        pixelPad.undo()
    }

    function redo() {
        pixelPad.redo()
    }

    function save() {
        document.getElementById('saveInput').value = JSON.stringify(pixelPad.save())
    }
    function load(){
        pixelPad.load(JSON.parse(document.getElementById('loadInput').value))
    }
</script>
</body>
<style>
    * {
        padding: 0;
        margin: 0;
        background-color: whitesmoke;
    }
</style>
</html>
